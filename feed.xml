<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-02-21T13:24:03+00:00</updated><id>/feed.xml</id><entry><title type="html">after_commit_everywhere的运作</title><link href="/2020/01/22/58d92d903bfe04e507ddb156ca3f4544.html" rel="alternate" type="text/html" title="after_commit_everywhere的运作" /><published>2020-01-22T00:00:00+00:00</published><updated>2020-01-22T00:00:00+00:00</updated><id>/2020/01/22/58d92d903bfe04e507ddb156ca3f4544</id><content type="html" xml:base="/2020/01/22/58d92d903bfe04e507ddb156ca3f4544.html">&lt;div&gt;[2] pry(main)&amp;gt; module A&lt;/div&gt;
&lt;div&gt;[2] pry(main)*   extend AfterCommitEverywhere&lt;/div&gt;
&lt;div&gt;[2] pry(main)* end&lt;/div&gt;
&lt;div&gt;=&amp;gt; A&lt;/div&gt;
&lt;div&gt;[3] pry(main)&amp;gt; binding.trace_tree(htmp: &amp;#39;after_commit_everywhere&amp;#39;) do&lt;/div&gt;
&lt;div&gt;[3] pry(main)*   module A&lt;/div&gt;
&lt;div&gt;[3] pry(main)*     ActiveRecord::Base.transaction do&lt;/div&gt;
&lt;div&gt;[3] pry(main)*       puts &amp;#34;We&amp;#39;re in transaction now&amp;#34;&lt;/div&gt;
&lt;div&gt;[3] pry(main)*&lt;/div&gt;
&lt;div&gt;[3] pry(main)*       ActiveRecord::Base.transaction do&lt;/div&gt;
&lt;div&gt;[3] pry(main)*         puts &amp;#34;More transactions&amp;#34;&lt;/div&gt;
&lt;div&gt;[3] pry(main)*         after_commit { puts &amp;#34;We&amp;#39;re all done!&amp;#34; }&lt;/div&gt;
&lt;div&gt;[3] pry(main)*       end&lt;/div&gt;
&lt;div&gt;[3] pry(main)*&lt;/div&gt;
&lt;div&gt;[3] pry(main)*       puts &amp;#34;Still in transaction…&amp;#34;&lt;/div&gt;
&lt;div&gt;[3] pry(main)*     end&lt;/div&gt;
&lt;div&gt;[3] pry(main)*   end&lt;/div&gt;
&lt;div&gt;[3] pry(main)* end&lt;/div&gt;
&lt;div&gt;   (53.9ms)  BEGIN&lt;/div&gt;
&lt;div&gt;We&amp;#39;re in transaction now&lt;/div&gt;
&lt;div&gt;More transactions&lt;/div&gt;
&lt;div&gt;Still in transaction…&lt;/div&gt;
&lt;div&gt;   (34.7ms)  COMMIT&lt;/div&gt;
&lt;div&gt;We&amp;#39;re all done!&lt;/div&gt;
&lt;div&gt;=&amp;gt; nil&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/58d92d903bfe04e507ddb156ca3f4544/d07b3baed3b7ecfb2a7a9b63ea700ec9.html&quot;&gt;&lt;img src=&quot;/assets/files/58d92d903bfe04e507ddb156ca3f4544/585330e65feefe77bcf2ff52146aa8b8.png&quot; alt=&quot;20200122_170636_887_after_commit_everywhere.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/58d92d903bfe04e507ddb156ca3f4544/be53a0541a6d36f6ecb879fa2c584b08.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;</content><author><name></name></author><category term="rails" /><category term="ruby" /><summary type="html">[2] pry(main)&gt; module A...</summary></entry><entry><title type="html">chewy的witchcraft的运作分析</title><link href="/2020/01/02/ae018986fb54e5d08f8c17a641b19513.html" rel="alternate" type="text/html" title="chewy的witchcraft的运作分析" /><published>2020-01-02T00:00:00+00:00</published><updated>2020-01-02T00:00:00+00:00</updated><id>/2020/01/02/ae018986fb54e5d08f8c17a641b19513</id><content type="html" xml:base="/2020/01/02/ae018986fb54e5d08f8c17a641b19513.html">&lt;div&gt;查看witchcraft!方法的定义，发现它只是给当前索引类设置了类变量_witchcraft为true，并确认parse、unparse这些gem有没有引入，此外没干什么&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# chewy-5.1.0/lib/chewy/type/witchcraft.rb
module Chewy
  class Type
    module Witchcraft
      extend ActiveSupport::Concern

      included do
        class_attribute :_witchcraft, instance_reader: false, instance_writer: false
      end

      module ClassMethods
        def witchcraft!
          self._witchcraft = true
          check_requirements!
        end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;料想它应该是在查询数据时才组建函数，于是在整个chewy的代码中搜索witchcraft字样，发现如下使用之处，那应该就没错了&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# chewy-5.1.0/lib/chewy/type/import.rb
def compose(object, crutches = nil, fields: [])
  crutches ||= Chewy::Type::Crutch::Crutches.new self, [object]

  if witchcraft? &amp;amp;&amp;amp; root.children.present?
    cauldron(fields: fields).brew(object, crutches)
  else
    root.compose(object, crutches, fields: fields)
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;于是跟踪一下在witchcraft模式下的import过程。先建一个索引类：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;class BookIndex &amp;lt; Chewy::Index
  define_type Book.includes(:author, :tags, :comments) do
    witchcraft!
    field :title, type: &amp;#39;text&amp;#39;
    field :author, value: -&amp;gt;{ author.name }
    field :tags, type: &amp;#39;keyword&amp;#39;, value: -&amp;gt;{ tags.map(&amp;amp;:name) }
    field :comments, type: &amp;#39;nested&amp;#39; do
      field :comment, value: -&amp;gt; (book, comment) { comment.comment }
      field :rating
    end
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;（此索引类必须写在文件里，因为parse需要根据代码语法树的位置来抽取代码，所以需要文件、行数）&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;然后执行一次import&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;[4] pry(main)&amp;gt; binding.trace_tree(htmp: &amp;#39;witchcraft_import&amp;#39;, transcode: true, no_methods: /perform_request/){ BookIndex::Book.import [1] }
   (46.6ms)  SELECT COUNT(*) FROM &amp;#34;books&amp;#34; WHERE &amp;#34;books&amp;#34;.&amp;#34;id&amp;#34; IN (1)
  Book Load (59.8ms)  SELECT &amp;#34;books&amp;#34;.* FROM &amp;#34;books&amp;#34; WHERE &amp;#34;books&amp;#34;.&amp;#34;id&amp;#34; IN (1)
  Dude Load (65.4ms)  SELECT &amp;#34;dudes&amp;#34;.* FROM &amp;#34;dudes&amp;#34; WHERE &amp;#34;dudes&amp;#34;.&amp;#34;id&amp;#34; IN (1)
  SQL (159.2ms)  SELECT &amp;#34;taggings&amp;#34;.*, &amp;#34;taggings&amp;#34;.&amp;#34;id&amp;#34; AS t0_r0, &amp;#34;taggings&amp;#34;.&amp;#34;tag_id&amp;#34; AS t0_r1, &amp;#34;taggings&amp;#34;.&amp;#34;taggable_id&amp;#34; AS t0_r2, &amp;#34;taggings&amp;#34;.&amp;#34;taggable_type&amp;#34; AS t0_r3, &amp;#34;taggings&amp;#34;.&amp;#34;tagger_id&amp;#34; AS t0_r4, &amp;#34;taggings&amp;#34;.&amp;#34;tagger_type&amp;#34; AS t0_r5, &amp;#34;taggings&amp;#34;.&amp;#34;context&amp;#34; AS t0_r6, &amp;#34;taggings&amp;#34;.&amp;#34;created_at&amp;#34; AS t0_r7, &amp;#34;tags&amp;#34;.&amp;#34;id&amp;#34; AS t1_r0, &amp;#34;tags&amp;#34;.&amp;#34;name&amp;#34; AS t1_r1, &amp;#34;tags&amp;#34;.&amp;#34;taggings_count&amp;#34; AS t1_r2 FROM &amp;#34;taggings&amp;#34; LEFT OUTER JOIN &amp;#34;tags&amp;#34; ON &amp;#34;tags&amp;#34;.&amp;#34;id&amp;#34; = &amp;#34;taggings&amp;#34;.&amp;#34;tag_id&amp;#34; WHERE &amp;#34;taggings&amp;#34;.&amp;#34;context&amp;#34; = ? AND &amp;#34;taggings&amp;#34;.&amp;#34;taggable_type&amp;#34; = &amp;#39;Book&amp;#39; AND &amp;#34;taggings&amp;#34;.&amp;#34;taggable_id&amp;#34; IN (1)  [[&amp;#34;context&amp;#34;, &amp;#34;tags&amp;#34;]]
  Comment Load (69.1ms)  SELECT &amp;#34;comments&amp;#34;.* FROM &amp;#34;comments&amp;#34; WHERE &amp;#34;comments&amp;#34;.&amp;#34;book_id&amp;#34; IN (1)
  BookIndex::Book Import (29470.0ms) {:index=&amp;gt;1}
=&amp;gt; true&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;得调用栈如下，即使屏蔽了faraday的perform_request，依然非常庞大&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/ae018986fb54e5d08f8c17a641b19513/51cf1c73235aea4a78971da6c973e4f2.html&quot;&gt;&lt;img src=&quot;/assets/files/ae018986fb54e5d08f8c17a641b19513/47a83afe63d3ef18df565a3ee5164e60.png&quot; alt=&quot;20200102_155803_086_witchcraft_import.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;于是尝试找出关键位置。从compose方法可见，witchcraft会用到Cauldron#brew，于是检查其代码&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# chewy-5.1.0/lib/chewy/type/witchcraft.rb
class Cauldron
  attr_reader :locals

  # @param type [Chewy::Type] type for composition
  # @param fields [Array&lt;symbol&gt;] restricts the fields for composition
  def initialize(type, fields: [])
    @type = type
    @locals = []
    @fields = fields
  end

  def brew(object, crutches = nil)
    alicorn.call(locals, object, crutches).as_json
  end

private

  def alicorn
    @alicorn ||= class_eval &amp;lt;&amp;lt;-RUBY, __FILE__, __LINE__ + 1
      -&amp;gt; (locals, object0, crutches) do
        #{composed_values(@type.root, 0)}
      end
    RUBY
  end

  def composed_values(field, nesting)
    source = &amp;lt;&amp;lt;-RUBY
      non_proc_values#{nesting} = #{non_proc_values(field, nesting)}
      proc_values#{nesting} = #{proc_values(field, nesting)}
      non_proc_values#{nesting}.merge!(proc_values#{nesting})
    RUBY
    source.gsub(&amp;#34;\n,&amp;#34;, &amp;#39;,&amp;#39;)
  end&lt;/symbol&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;可见composed_values方法会返回non_pro_values字样，于是在调用栈中查找该返回值，得：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/ae018986fb54e5d08f8c17a641b19513/be53a0541a6d36f6ecb879fa2c584b08.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;即是，alicorn方法会生成以下block，并缓存于@alicorn中：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;-&amp;gt; (locals, object0, crutches) do
  non_proc_values0 =               (if object0.is_a?(Hash)
      {
        &amp;#39;title&amp;#39;.freeze =&amp;gt; object0.has_key?(:title) ? object0[:title] : object0[&amp;#39;title&amp;#39;], &amp;#39;comments&amp;#39;.freeze =&amp;gt;
        # ...
      }
    else
      {
        &amp;#39;title&amp;#39;.freeze =&amp;gt; object0.title, &amp;#39;comments&amp;#39;.freeze =&amp;gt;
        # ...
      }
    end)
  
  proc_values0 =               {
      &amp;#39;author&amp;#39;.freeze =&amp;gt; (object0.author.name), &amp;#39;tags&amp;#39;.freeze =&amp;gt; (object0.tags.map(&amp;amp;:name))
    }
  
  non_proc_values0.merge!(proc_values0)
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;当要调用时，object0会传入Book对象，至于crutches参数，因为定义索引时没有为comments数据使用crutches模式，所以生成的代码里也没有crutches字眼的替换&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;再看看非witchcraft的源码。根据源码，witchcraft模式下json数据的生成是依靠cauldron(fields: fields).brew(object, crutches)，而非witchcraft则是root.compose(object, crutches, fields: fields)。于是查找compose，得：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# chewy-5.1.0/lib/chewy/fields/root.rb
def compose(object, crutches = nil, fields: [])
  result = evaluate([object, crutches])

  if children.present?
    child_fields = if fields.present?
      child_hash.slice(*fields).values
    else
      children
    end

    child_fields.each_with_object({}) do |field, memo|
      memo.merge!(field.compose(result, crutches) || {})
    end.as_json
  elsif fields.present?
    result.as_json(only: fields, root: false)
  else
    result.as_json(root: false)
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;root的compose如上，root下的field以及field下的field，递归如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# chewy-5.1.0/lib/chewy/fields/base.rb
def compose(*objects)
  result = evaluate(objects)

  if children.present? &amp;amp;&amp;amp; !multi_field?
    result = if result.respond_to?(:to_ary)
      result.to_ary.map { |item| compose_children(item, *objects) }
    else
      compose_children(result, *objects)
    end
  end

  {name =&amp;gt; result}
end

private

def evaluate(objects)
  object = objects.first

  if value.is_a?(Proc)
    if value.arity.zero?
      object.instance_exec(&amp;amp;value)
    elsif value.arity &amp;lt; 0
      value.call(*object)
    else
      value.call(*objects.first(value.arity))
    end
  else
    message = value.is_a?(Symbol) || value.is_a?(String) ? value.to_sym : name

    if object.is_a?(Hash)
      if object.key?(message)
        object[message]
      else
        object[message.to_s]
      end
    else
      object.send(message)
    end
  end
end

def compose_children(value, *parent_objects)
  return unless value

  children.each_with_object({}) do |field, result|
    result.merge!(field.compose(value, *parent_objects) || {})
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;可见每读取一个字段的值，都要判断索引字段是否通过Proc定义，其中还有一些instance_exec、send之类的操作，性能应该不及witchcraft里代码拼接的写死&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;再检查brew和compose运行时的调用栈底下有多少函数调用（brew应该调用两次再作检查，因为第一次需要生产代码）：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;compose有2225个调用&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/ae018986fb54e5d08f8c17a641b19513/91eee3f8d75dbb327ede474944726554.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;brew有2115&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/ae018986fb54e5d08f8c17a641b19513/f7cb588f62bc16ba6c8ac0b4956bd711.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;好吧，相差不大，而实际从时间上看，在个人机器上也是几十毫秒的差别，不过有提升的话还是尽量用一下witchcraft吧……&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;</content><author><name></name></author><category term="elasticsearch" /><category term="ruby" /><summary type="html">查看witchcraft!方法的定义，发现它只是给当前索引类设置了类变量_witchcraft为true，并确认parse、unparse这些gem有没有引入，此外没干什么...</summary></entry><entry><title type="html">chewy的同步策略</title><link href="/2019/12/29/255570490c4f7ce1dc3f82788005f4d1.html" rel="alternate" type="text/html" title="chewy的同步策略" /><published>2019-12-29T00:00:00+00:00</published><updated>2019-12-29T00:00:00+00:00</updated><id>/2019/12/29/255570490c4f7ce1dc3f82788005f4d1</id><content type="html" xml:base="/2019/12/29/255570490c4f7ce1dc3f82788005f4d1.html">&lt;div&gt;跟踪一下Chewy.strategy(:atomic){}的运作：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;[6] pry(main)&amp;gt; binding.trace_tree(htmp: &amp;#39;chewy_atomic&amp;#39;, no_methods: /perform_request/){ Chewy.strategy(:atomic){ books.each{ |b| b.update(year: 1994) } } }
Chewy strategies stack: [2] &amp;lt;- atomic @ (pry):6
   (36.1ms)  begin transaction
  SQL (57.9ms)  UPDATE &amp;#34;books&amp;#34; SET &amp;#34;year&amp;#34; = ?, &amp;#34;updated_at&amp;#34; = ? WHERE &amp;#34;books&amp;#34;.&amp;#34;id&amp;#34; = ?  [[&amp;#34;year&amp;#34;, 1994], [&amp;#34;updated_at&amp;#34;, &amp;#34;2019-12-29 13:43:05.099905&amp;#34;], [&amp;#34;id&amp;#34;, 1]]
   (43.2ms)  commit transaction
   (51.0ms)  begin transaction
  SQL (58.6ms)  UPDATE &amp;#34;books&amp;#34; SET &amp;#34;year&amp;#34; = ?, &amp;#34;updated_at&amp;#34; = ? WHERE &amp;#34;books&amp;#34;.&amp;#34;id&amp;#34; = ?  [[&amp;#34;year&amp;#34;, 1994], [&amp;#34;updated_at&amp;#34;, &amp;#34;2019-12-29 13:43:08.011823&amp;#34;], [&amp;#34;id&amp;#34;, 2]]
   (43.1ms)  commit transaction
   (48.5ms)  SELECT COUNT(*) FROM &amp;#34;books&amp;#34; WHERE &amp;#34;books&amp;#34;.&amp;#34;id&amp;#34; IN (1, 2)
  Book Load (68.3ms)  SELECT &amp;#34;books&amp;#34;.* FROM &amp;#34;books&amp;#34; WHERE &amp;#34;books&amp;#34;.&amp;#34;id&amp;#34; IN (1, 2)
  Dude Load (75.2ms)  SELECT &amp;#34;dudes&amp;#34;.* FROM &amp;#34;dudes&amp;#34; WHERE &amp;#34;dudes&amp;#34;.&amp;#34;id&amp;#34; IN (1, 2)
  SQL (156.8ms)  SELECT &amp;#34;taggings&amp;#34;.*, &amp;#34;taggings&amp;#34;.&amp;#34;id&amp;#34; AS t0_r0, &amp;#34;taggings&amp;#34;.&amp;#34;tag_id&amp;#34; AS t0_r1, &amp;#34;taggings&amp;#34;.&amp;#34;taggable_id&amp;#34; AS t0_r2, &amp;#34;taggings&amp;#34;.&amp;#34;taggable_type&amp;#34; AS t0_r3, &amp;#34;taggings&amp;#34;.&amp;#34;tagger_id&amp;#34; AS t0_r4, &amp;#34;taggings&amp;#34;.&amp;#34;tagger_type&amp;#34; AS t0_r5, &amp;#34;taggings&amp;#34;.&amp;#34;context&amp;#34; AS t0_r6, &amp;#34;taggings&amp;#34;.&amp;#34;created_at&amp;#34; AS t0_r7, &amp;#34;tags&amp;#34;.&amp;#34;id&amp;#34; AS t1_r0, &amp;#34;tags&amp;#34;.&amp;#34;name&amp;#34; AS t1_r1, &amp;#34;tags&amp;#34;.&amp;#34;taggings_count&amp;#34; AS t1_r2 FROM &amp;#34;taggings&amp;#34; LEFT OUTER JOIN &amp;#34;tags&amp;#34; ON &amp;#34;tags&amp;#34;.&amp;#34;id&amp;#34; = &amp;#34;taggings&amp;#34;.&amp;#34;tag_id&amp;#34; WHERE &amp;#34;taggings&amp;#34;.&amp;#34;context&amp;#34; = ? AND &amp;#34;taggings&amp;#34;.&amp;#34;taggable_type&amp;#34; = &amp;#39;Book&amp;#39; AND &amp;#34;taggings&amp;#34;.&amp;#34;taggable_id&amp;#34; IN (1, 2)  [[&amp;#34;context&amp;#34;, &amp;#34;tags&amp;#34;]]
  EntertainmentIndex::Book Import (15270.4ms) {:index=&amp;gt;2}
Chewy strategies stack: [2] -&amp;gt; atomic, now urgent @ (pry):6
[7] pry(main)&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;得调用栈如下：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/255570490c4f7ce1dc3f82788005f4d1/675bf0b8b3f69597ecd4e7e13d38980f.html&quot;&gt;&lt;img src=&quot;/assets/files/255570490c4f7ce1dc3f82788005f4d1/c611c07bdda7f6da59a1eda8d575cbce.png&quot; alt=&quot;20191229_134304_402_chewy_atomic.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而从日志可见，ES的import是在所有commit之后才执行的（其实平时这两个update还应该用transaction包起来的）。这个动作位于Chewy::Strategy#pop之中&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/255570490c4f7ce1dc3f82788005f4d1/be53a0541a6d36f6ecb879fa2c584b08.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;wrap中所作的push和pop实际上干的是，根据参数指定的名字找到具体策略类并实例化后将其压入栈中，出栈时调用策略对象的leave方法&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# chewy-5.1.0/lib/chewy/strategy.rb
module Chewy
  class Strategy
    def initialize
      @stack = [resolve(Chewy.root_strategy).new]
    end

    def current
      @stack.last
    end

    def push(name)
      result = @stack.push resolve(name).new
      debug &amp;#34;[#{@stack.size - 1}] &amp;lt;- #{current.name}&amp;#34; if @stack.size &amp;gt; 2
      result
    end

    def pop
      raise &amp;#34;Can&amp;#39;t pop root strategy&amp;#34; if @stack.one?
      result = @stack.pop.tap(&amp;amp;:leave)
      debug &amp;#34;[#{@stack.size}] -&amp;gt; #{result.name}, now #{current.name}&amp;#34; if @stack.size &amp;gt; 1
      result
    end

    def wrap(name)
      stack = push(name)
      yield
    ensure
      pop if stack
    end
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而栈底固定的策略类是Urgent，源码如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# chewy-5.1.0/lib/chewy/strategy/urgent.rb
module Chewy
  class Strategy
    class Urgent &amp;lt; Base
      def update(type, objects, _options = {})
        type.import!(Array.wrap(objects))
      end
    end
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;刚才使用的atomic则如下，其update方法只是将该更新的索引及文档id收集起来，到了leave被调用时才实际地查数据并推到ES去&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# chewy-5.1.0/lib/chewy/strategy/atomic.rb
module Chewy
  class Strategy
    class Atomic &amp;lt; Base
      def initialize
        @stash = {}
      end

      def update(type, objects, _options = {})
        @stash[type] ||= []
        @stash[type] |= type.root.id ? Array.wrap(objects) : type.adapter.identify(objects)
      end

      def leave
        @stash.all? { |type, ids| type.import!(ids) }
      end
    end
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;该update方法正是在activerecord的after_commit中被回调（由model的update_index所定义），如下。如果没有使用Chewy.strategy(:atomic){}的话，则after_commit中查到的Chewy::Strategy#current将会是初始化在栈底的Urgent策略，导致在没有将多个不同类型的model用一个transaction包裹，发起多次ES的import。（不过在嵌套transaction（即require_new）的情况里，还是会每个commit一次import）&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/255570490c4f7ce1dc3f82788005f4d1/91eee3f8d75dbb327ede474944726554.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;再检查Resque、Sidekiq、Shoryuken的代码，可见它们都是继承了Atomic，然后在leave中实现对应的队列操作，所以它们都是在Chewy.strategy的block的最后才执行批量更新ES。&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而因为Chewy.strategy实质上是个栈，所以可以实现以下效果：如果希望某些数据更新要即时同步，可以通过新增一层Chewy.strategy(:urgent)来实现。不过暂时没发现什么时候会有这样的需求……&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Chewy.strategy(:atomic) do
  city1.do_update!
  Chewy.strategy(:urgent) do
    city2.do_update!
    city3.do_update!
    # there will be 2 update index requests for city2 and city3
  end
  city4..do_update!
  # city1 and city4 will be grouped in one index update request
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;另外要注意的是，因为Strategy的update方法是在after_commit回调中调用的，所以transaction的block需要放在Chewy.strategy的block中，否则，在执行Chewy.strategy后，策略栈会退回到urgent，这时transaction结束前调的after_commit回调就是urgent的update，导致ES不是批量更新。&lt;/div&gt;</content><author><name></name></author><category term="elasticsearch" /><category term="ruby" /><summary type="html">跟踪一下Chewy.strategy(:atomic){}的运作：...</summary></entry><entry><title type="html">zipkin-tracer的运作</title><link href="/2019/10/20/589723fa4ca5e34cf08d53a8eaf781de.html" rel="alternate" type="text/html" title="zipkin-tracer的运作" /><published>2019-10-20T00:00:00+00:00</published><updated>2019-10-20T00:00:00+00:00</updated><id>/2019/10/20/589723fa4ca5e34cf08d53a8eaf781de</id><content type="html" xml:base="/2019/10/20/589723fa4ca5e34cf08d53a8eaf781de.html">&lt;div&gt;为研究zipkin以及zipkin-trace这个gem，对 &lt;a href=&quot;https://github.com/openzipkin/zipkin-ruby-example&quot;&gt;https://github.com/openzipkin/zipkin-ruby-example&lt;/a&gt; 的代码稍作修改，并复制成4个不同端口的服务（8081、9000、9001、9002），使其调用链如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;8081 frontend
|_ 9000 backend
|   |_ 9001 deep_backend
\_ 9002 another_backend&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;并对zipkin-tracer这个gem的代码作如下改动，只跟踪zipkin-tracer本层的rack运动，排除底层：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# zipkin-tracer-0.40.0/lib/zipkin-tracer/rack/zipkin-tracer.rb
module ZipkinTracer
  class RackHandler
    def call(env)
      port = env[&amp;#39;SERVER_PORT&amp;#39;]
      binding.trace_tree(htmp: &amp;#34;zip-#{port}&amp;#34;, no_methods: /pass_to_under/, warm: port) do
        _call(env)
      end
    end

    def _call(env)
      zipkin_env = ZipkinEnv.new(env, @config)
      trace_id = zipkin_env.trace_id
      TraceContainer.with_trace_id(trace_id) do
        if !trace_id.sampled?
          pass_to_under(env)
        else
          @tracer.with_new_span(trace_id, span_name(env)) do |span|
            trace!(span, zipkin_env) { pass_to_under(env) }
          end
        end
      end
    end

    def pass_to_under(env)
      @app.call(env)
    end
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;然后启动zipkin的docker和这4个服务，对8081进行访问，使zipkin记录整个链路如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/be53a0541a6d36f6ecb879fa2c584b08.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;并获得4份zipkin-tracer的调用轨迹：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/15fbef7e5a86e32cbd9ecc683997c0b6.html&quot;&gt;&lt;img src=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/edf893b431d508d3b104b0eaa171da3d.png&quot; alt=&quot;20191020_153300_187_zip-8081.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/614d6b5e68cf2726fb84bb2dd467521f.html&quot;&gt;&lt;img src=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/10bea98c295deebb1a25fe903c37c79f.png&quot; alt=&quot;20191020_153301_025_zip-9000.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/8a21272eddb727ea27efd8abbf81f8c7.html&quot;&gt;&lt;img src=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/4d49d753361308084c076182c62f1dec.png&quot; alt=&quot;20191020_153301_856_zip-9001.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/b05f5a8c940f37e89df9aa052168b506.html&quot;&gt;&lt;img src=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/6aba9c299020097cd54cace4d98f9e6a.png&quot; alt=&quot;20191020_153305_638_zip-9002.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;对照zipkin的图和源码的调用栈，可见顶层调用方8081从env生成的trace_id对象如下，其span_id被当做了整个调用链的trace_id，其parent_id是没有的&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/91eee3f8d75dbb327ede474944726554.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而最深的被调用方9001的trace_id对象中，parent_id为9000的span_id&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/f7cb588f62bc16ba6c8ac0b4956bd711.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;这些xxx_id的生成逻辑如下源码所示，整个链路的trace_id、调用方的parent_span_id、调用方分配给被调用方的span_id，都可从header里取出。如果header没带有这些键，则代表这是链路的开头，需要生成&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# zipkin-tracer-0.40.0/lib/zipkin-tracer/rack/zipkin_env.rb
B3_SINGLE_HEADER = &amp;#39;HTTP_B3&amp;#39;.freeze
B3_REQUIRED_HEADERS = %w[HTTP_X_B3_TRACEID HTTP_X_B3_SPANID].freeze
B3_OPT_HEADERS = %w[HTTP_X_B3_PARENTSPANID HTTP_X_B3_SAMPLED HTTP_X_B3_FLAGS].freeze

def retrieve_or_generate_ids
  if called_with_zipkin_b3_single_header?
    trace_id, span_id, parent_span_id, sampled, flags =
      B3SingleHeaderFormat.parse_from_header(@env[B3_SINGLE_HEADER])
    shared = true
  elsif called_with_zipkin_headers?
    trace_id, span_id, parent_span_id, sampled, flags = @env.values_at(*B3_REQUIRED_HEADERS, *B3_OPT_HEADERS)
    shared = true
  end

  unless trace_id
    span_id = TraceGenerator.new.generate_id
    trace_id = TraceGenerator.new.generate_id_from_span_id(span_id)
    parent_span_id = nil
    shared = false
  end

  [trace_id, span_id, parent_span_id, sampled, flags, shared]
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;然后就是发送span到zipkin服务器的过程，调用栈如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/589723fa4ca5e34cf08d53a8eaf781de/caebd5802a502287b56167f6208b00f3.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;源码如下，实际对于底层app的call，被包裹成block由with_new_span来调用，并在调用前后记录trace_id和调用时长，调用后还要flush!到接收zipkin数据的端点，而端点都是继承ZipkinSenderBase然后重写flush!方法的&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# zipkin-tracer-0.40.0/lib/zipkin-tracer/zipkin_sender_base.rb
module Trace
  class ZipkinSenderBase

    def initialize(options={})
      @options = options
      reset
    end

    def with_new_span(trace_id, name)
      span = start_span(trace_id, name)
      result = yield span
      end_span(span)
      result
    end

    def end_span(span, timestamp = Time.now)
      span.close(timestamp)
      # If in a thread not handling incoming http requests, it will not have Kind::SERVER, so the span
      # will never be flushed and will cause memory leak.
      # If no parent span, then current span needs to flush when it ends.
      if !span.has_parent_span? || span.kind == Trace::Span::Kind::SERVER
        flush!
        reset
      end
    end

    def start_span(trace_id, name, timestamp = Time.now)
      span = Span.new(name, trace_id, timestamp)
      span.local_endpoint = Trace.default_endpoint
      store_span(trace_id, span)
      span
    end

    def flush!
      raise &amp;#34;not implemented&amp;#34;
    end
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而被调用方的span_id则是由调用方生成的，从FaradayHandler代码就可知，在发起调用前，会生成新的span_id塞入env中，之后才真正的去请求&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# zipkin-tracer-0.40.0/lib/zipkin-tracer/faraday/zipkin-tracer.rb
module ZipkinTracer
  class FaradayHandler &amp;lt; ::Faraday::Middleware

    def call(env)
      trace_id = TraceGenerator.new.next_trace_id
      TraceContainer.with_trace_id(trace_id) do
        b3_headers.each do |method, header|
          env[:request_headers][header] = trace_id.send(method).to_s
        end
        if Trace.tracer &amp;amp;&amp;amp; trace_id.sampled?
          trace!(env, trace_id)
        else
          @app.call(env)
        end
      end
    end

    def b3_headers
      {
        trace_id: &amp;#39;X-B3-TraceId&amp;#39;,
        parent_id: &amp;#39;X-B3-ParentSpanId&amp;#39;,
        span_id: &amp;#39;X-B3-SpanId&amp;#39;,
        sampled: &amp;#39;X-B3-Sampled&amp;#39;,
        flags: &amp;#39;X-B3-Flags&amp;#39;
      }
    end

    def trace!(env, trace_id)
      response = nil
      # handle either a URI object (passed by Faraday v0.8.x in testing), or something string-izable
      method = env[:method].to_s
      url = env[:url].respond_to?(:host) ? env[:url] : URI.parse(env[:url].to_s)
      remote_endpoint = Trace::Endpoint.remote_endpoint(url, @service_name) # The endpoint we are calling.
      Trace.tracer.with_new_span(trace_id, method.downcase) do |span|
        @span = span # So we can record on exceptions
        # annotate with method (GET/POST/etc.) and uri path
        span.kind = Trace::Span::Kind::CLIENT
        span.remote_endpoint = remote_endpoint
        span.record_tag(Trace::Span::Tag::METHOD, method.upcase)
        span.record_tag(Trace::Span::Tag::PATH, url.path)
        response = @app.call(env).on_complete do |renv|
          span.record_status(renv[:status])
        end
      end
      response
    rescue Net::ReadTimeout
      record_error(@span, &amp;#39;Request timed out.&amp;#39;)
      raise
    rescue Faraday::ConnectionFailed
      record_error(@span, &amp;#39;Request connection failed.&amp;#39;)
      raise
    rescue Faraday::ClientError
      record_error(@span, &amp;#39;Generic Faraday client error.&amp;#39;)
      raise
    end
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;</content><author><name></name></author><category term="ruby" /><category term="zipkin" /><summary type="html">为研究zipkin以及zipkin-trace这个gem，对 https://github.com/openzipkin/zipkin-ruby-example 的代码稍作修改，并复制成4个不同端口的服务（8081、9000、9001、9002），使其调用链如下...</summary></entry><entry><title type="html">ruby-kafka的自动与手动提交偏移量</title><link href="/2019/10/15/571b852e51679f302738f31ef25e8c04.html" rel="alternate" type="text/html" title="ruby-kafka的自动与手动提交偏移量" /><published>2019-10-15T00:00:00+00:00</published><updated>2019-10-15T00:00:00+00:00</updated><id>/2019/10/15/571b852e51679f302738f31ef25e8c04</id><content type="html" xml:base="/2019/10/15/571b852e51679f302738f31ef25e8c04.html">&lt;div&gt;根据官方文档，如果想手工控制commit时机，需要在轮询时将automatically_mark_as_processed选项传false，然后自行调用mark_message_as_processed和commit_offsets。&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;看轮询源码如下：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# ruby-kafka-0.7.10/lib/kafka/consumer.rb
def each_message(min_bytes: 1, max_bytes: 10485760, max_wait_time: 1, automatically_mark_as_processed: true)
  # ...

  consumer_loop do
    batches = fetch_batches

    batches.each do |batch|
      batch.messages.each do |message|
        # ...

        begin
          yield message unless message.is_control_record
          @current_offsets[message.topic][message.partition] = message.offset
        rescue =&amp;gt; e
          location = &amp;#34;#{message.topic}/#{message.partition} at offset #{message.offset}&amp;#34;
          backtrace = e.backtrace.join(&amp;#34;\n&amp;#34;)
          @logger.error &amp;#34;Exception raised when processing #{location} -- #{e.class}: #{e}\n#{backtrace}&amp;#34;

          raise ProcessingError.new(message.topic, message.partition, message.offset)
        end

        mark_message_as_processed(message) if automatically_mark_as_processed
        @offset_manager.commit_offsets_if_necessary

        # ...
      end
    end

    # We may not have received any messages, but it&amp;#39;s still a good idea to
    # commit offsets if we&amp;#39;ve processed messages in the last set of batches.
    # This also ensures the offsets are retained if we haven&amp;#39;t read any messages
    # since the offset retention period has elapsed.
    @offset_manager.commit_offsets_if_necessary
  end
end

def mark_message_as_processed(message)
  @offset_manager.mark_as_processed(message.topic, message.partition, message.offset)
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;在这里，automatically_mark_as_processed所控制的，其实是“是否将当前消息的offset更新到@offset_manager的缓存里”。offset_manager内部是存有每个topic每个partition的偏移量的：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# ruby-kafka-0.7.10/lib/kafka/offset_manager.rb
def mark_as_processed(topic, partition, offset)
  @uncommitted_offsets += 1
  @processed_offsets[topic] ||= {}

  # The committed offset should always be the offset of the next message that the
  # application will read, thus adding one to the last message processed.
  @processed_offsets[topic][partition] = offset + 1
  @logger.debug &amp;#34;Marking #{topic}/#{partition}:#{offset} as processed&amp;#34;
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;除了设置automatically_mark_as_processed选项，实际上，生成consumer时还需要设置commit_interval和commit_threshold为零，因为轮询中每取一条消息都会检查是否太长时间未commit或太多消息未commit：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# ruby-kafka-0.7.10/lib/kafka/offset_manager.rb
def commit_offsets_if_necessary
  recommit = recommit_timeout_reached?
  if recommit || commit_timeout_reached? || commit_threshold_reached?
    commit_offsets(recommit)
  end
end

def commit_timeout_reached?
  @commit_interval != 0 &amp;amp;&amp;amp; seconds_since_last_commit &amp;gt;= @commit_interval
end

def commit_threshold_reached?
  @commit_threshold != 0 &amp;amp;&amp;amp; @uncommitted_offsets &amp;gt;= @commit_threshold
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而consumer_loop的末尾之所以还有一个commit_offsets_if_necessary，是因为consumer_loop在没有获取到新消息时，也不是完全阻塞的。如下，当fetcher没数据时，它只是睡眠一下然后返回一个空数组&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# ruby-kafka-0.7.10/lib/kafka/consumer.rb
def fetch_batches
  # ...

  if !@fetcher.data?
    @logger.debug &amp;#34;No batches to process&amp;#34;
    sleep 2
    []
  else
    tag, message = @fetcher.poll

    case tag
    when :batches
      # make sure any old batches, fetched prior to the completion of a consumer group sync,
      # are only processed if the batches are from brokers for which this broker is still responsible.
      message.select { |batch| @group.assigned_to?(batch.topic, batch.partition) }
    when :exception
      raise message
    end
  end

  # ...
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;fetcher只是一个ruby Queue，真正的读取数据，是在consumer轮询时，它新建的一个线程，从kafka获取数据去填充这个Queue。另外，从step方法也可见，因为offset的提交时机是不定的，所以fetcher必须自己也缓存一份offset，否则会可能拉取到重复数据&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# ruby-kafka-0.7.10/lib/kafka/fetcher.rb
def start
  # ...
  @thread = Thread.new do
    while @running
      loop
    end
    @logger.info &amp;#34;#{@group} Fetcher thread exited.&amp;#34;
  end
  # ...
end

def loop
  # ...
  step
  # ..
end

def step
  batches = fetch_batches

  batches.each do |batch|
    # ...
    @next_offsets[batch.topic][batch.partition] = batch.last_offset + 1 unless batch.unknown_last_offset?
  end

  @queue &amp;lt;&amp;lt; [:batches, batches, current_reset_counter]
  # ...
end

def poll
  tag, message, reset_counter = @queue.deq
  # ...
  return [tag, message]
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;</content><author><name></name></author><category term="kafka" /><category term="ruby" /><summary type="html">根据官方文档，如果想手工控制commit时机，需要在轮询时将automatically_mark_as_processed选项传false，然后自行调用mark_message_as_processed和commit_offsets。...</summary></entry><entry><title type="html">在mini_prof中加入query cache的统计</title><link href="/2019/07/26/ebee89830dfcde2b02dec4229d2b6ced.html" rel="alternate" type="text/html" title="在mini_prof中加入query cache的统计" /><published>2019-07-26T00:00:00+00:00</published><updated>2019-07-26T00:00:00+00:00</updated><id>/2019/07/26/ebee89830dfcde2b02dec4229d2b6ced</id><content type="html" xml:base="/2019/07/26/ebee89830dfcde2b02dec4229d2b6ced.html">&lt;div&gt;（其实用bullet也可以，不过顺便了解下mini_prof的运作吧）&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;在Gemfile加入mini_prof后，跟踪一下查询数据库时它是如何记录耗时和调用栈的&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;binding.trace_tree(htmp: &amp;#39;mini_porfiler&amp;#39;){ Member.limit(1).to_a }&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;得调用栈如下：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/ebee89830dfcde2b02dec4229d2b6ced/e8c4b5fd26de67a874407ed28b5b59fc.html&quot;&gt;&lt;img src=&quot;/assets/files/ebee89830dfcde2b02dec4229d2b6ced/35c74bacfbf1cfe29143f0479c66d8fc.png&quot; alt=&quot;20190726_161505_264_mini_porfiler.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;在其中搜索mini，得：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/ebee89830dfcde2b02dec4229d2b6ced/be53a0541a6d36f6ecb879fa2c584b08.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;找到这个被重写的async_exec，发现它是使用record_sql方法收集sql及耗时&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;def async_exec(*args, &amp;amp;blk)
  return async_exec_without_profiling(*args, &amp;amp;blk) unless SqlPatches.should_measure?

  start        = Process.clock_gettime(Process::CLOCK_MONOTONIC)
  result       = exec_without_profiling(*args, &amp;amp;blk)
  elapsed_time = SqlPatches.elapsed_time(start)
  record       = ::Rack::MiniProfiler.record_sql(args[0], elapsed_time)
  result.instance_variable_set(&amp;#34;@miniprofiler_sql_id&amp;#34;, record) if result

  result
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;于是，我们也可以利用这个方法来收集query cache出现的地方，而因为query cache不会发出sql，不能通过重写adapter的xx_exec来拦截，但它会输出日志，所以对该输出进行拦截即可&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;module QueryCacheProfiler
  class Railtie &amp;lt; ::Rails::Railtie
    initializer &amp;#34;rack_mini_profiler.query_cache&amp;#34; do |app|
      ::ActiveSupport::Notifications.subscribe(&amp;#39;sql.active_record&amp;#39;) do |*args|
        opt = args[-1]
        next if opt[:name] != &amp;#34;CACHE&amp;#34;
        duration = 1000.0 * (args[2] - args[1])
        ::Rack::MiniProfiler.record_sql(&amp;#34;(CACHE) #{opt[:sql]}&amp;#34;, duration)
      end
    end
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;甚至可以包装成一个gem来使用，这样mini_prof的结果就会带上query cache的统计：&lt;a href=&quot;https://github.com/turnon/query_cache_profiler&quot;&gt;https://github.com/turnon/query_cache_profiler&lt;/a&gt;&lt;/div&gt;</content><author><name></name></author><category term="rails" /><category term="ruby" /><summary type="html">（其实用bullet也可以，不过顺便了解下mini_prof的运作吧）...</summary></entry><entry><title type="html">rails/spring的运作分析</title><link href="/2019/07/01/64ea7d8a2c7fc2cabdb0d69a990f8905.html" rel="alternate" type="text/html" title="rails/spring的运作分析" /><published>2019-07-01T00:00:00+00:00</published><updated>2019-07-01T00:00:00+00:00</updated><id>/2019/07/01/64ea7d8a2c7fc2cabdb0d69a990f8905</id><content type="html" xml:base="/2019/07/01/64ea7d8a2c7fc2cabdb0d69a990f8905.html">&lt;div&gt;rails新建项目时，已经进行过binstub。这时输入rails c，即调用了spring，会打印出“Running via Spring preloader in process”的字样。可凭这些日志信息，到源码中查找它的调用过程。发现日志由以下方法输出，于是加入pp caller，打印出它是怎样被调用的&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# spring-2.0.2/lib/spring/application.rb
def serve(client)
  # ...

  pid = fork {
    pp caller
    STDERR.puts &amp;#34;Running via Spring preloader in process #{Process.pid}&amp;#34; unless Spring.quiet

    # ...
  }

  disconnect_database

  log &amp;#34;forked #{pid}&amp;#34;
  manager.puts pid

  wait pid, streams, client
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;再次输入spring stop; rails c，得调用栈如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;➜  rays git:(master) ✗ rails c
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/pry-rails-0.3.6/lib/pry-rails/prompt.rb:36: warning: constant Pry::Prompt::MAP is deprecated
[&amp;#34;/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/railties-5.2.1/lib/rails/railtie.rb:127:in `config&amp;#39;&amp;#34;,
&amp;#34;/home/z/test_ruby/rays/config/application.rb:12:in `&lt;class:application&gt;&amp;#39;&amp;#34;,
&amp;#34;/home/z/test_ruby/rays/config/application.rb:10:in `&lt;module:rays&gt;&amp;#39;&amp;#34;,
&amp;#34;/home/z/test_ruby/rays/config/application.rb:9:in `&amp;lt;top (required)=&quot;&quot;&amp;gt;&amp;#39;&amp;#34;,
&amp;#34;/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application.rb:92:in `require&amp;#39;&amp;#34;,
&amp;#34;/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application.rb:92:in `preload&amp;#39;&amp;#34;,
&amp;#34;/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application.rb:153:in `serve&amp;#39;&amp;#34;,
&amp;#34;/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application.rb:141:in `block in run&amp;#39;&amp;#34;,
&amp;#34;/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application.rb:135:in `loop&amp;#39;&amp;#34;,
&amp;#34;/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application.rb:135:in `run&amp;#39;&amp;#34;,
&amp;#34;/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application/boot.rb:19:in `&amp;lt;top (required)=&quot;&quot;&amp;gt;&amp;#39;&amp;#34;,
&amp;#34;/home/z/.rbenv/versions/2.5.1/lib/ruby/2.5.0/rubygems/core_ext/kernel_require.rb:59:in `require&amp;#39;&amp;#34;,
&amp;#34;/home/z/.rbenv/versions/2.5.1/lib/ruby/2.5.0/rubygems/core_ext/kernel_require.rb:59:in `require&amp;#39;&amp;#34;,
&amp;#34;-e:1:in `&amp;lt;/top&amp;gt;&amp;lt;/top&amp;gt;&lt;/module:rays&gt;&lt;/class:application&gt;&lt;/code&gt;&lt;main&gt;&lt;code&gt;&amp;#39;&amp;#34;]
Running via Spring preloader in process 4152
Loading development environment (Rails 5.2.1)
[1] pry(main)&amp;gt;&lt;/code&gt;&lt;/main&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;其调用可追溯至以下文件&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# spring-2.0.2/lib/spring/application/boot.rb
Process.setsid

require &amp;#34;spring/application&amp;#34;

app = Spring::Application.new(
  UNIXSocket.for_fd(3),
  Spring::JSON.load(ENV.delete(&amp;#34;SPRING_ORIGINAL_ENV&amp;#34;).dup),
  Spring::Env.new(log_file: IO.for_fd(4))
)

Signal.trap(&amp;#34;TERM&amp;#34;) { app.terminate }

Spring::ProcessTitleUpdater.run { |distance|
  &amp;#34;spring app    | #{app.app_name} | started #{distance} ago | #{app.app_env} mode&amp;#34;
}

app.eager_preload if ENV.delete(&amp;#34;SPRING_PRELOAD&amp;#34;) == &amp;#34;1&amp;#34;
app.run&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;然后app.run会等待manager和@interrupt，即上面的UNIXSocket.for_fd(3)，以及IO.pipe的读端，一旦可读，则检查状态，执行exit或serve&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# spring-2.0.2/lib/spring/application.rb
def run
  state :running
  manager.puts

  loop do
    IO.select [manager, @interrupt.first]

    if terminating? || watcher_stale? || preload_failed?
      exit
    else
      serve manager.recv_io(UNIXSocket)
    end
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;那么UNIXSocket.for_fd(3)除了loop之前写了一下，平时是如何写入，以作进程间通信的呢？在源码里搜索数字3，得：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# spring-2.0.2/lib/spring/application_manager.rb
module Spring
  class ApplicationManager

    def start
      start_child
    end

    private

    def start_child(preload = false)
      @child, child_socket = UNIXSocket.pair

      Bundler.with_clean_env do
        @pid = Process.spawn(
          {
            &amp;#34;RAILS_ENV&amp;#34;           =&amp;gt; app_env,
            &amp;#34;RACK_ENV&amp;#34;            =&amp;gt; app_env,
            &amp;#34;SPRING_ORIGINAL_ENV&amp;#34; =&amp;gt; JSON.dump(Spring::ORIGINAL_ENV),
            &amp;#34;SPRING_PRELOAD&amp;#34;      =&amp;gt; preload ? &amp;#34;1&amp;#34; : &amp;#34;0&amp;#34;
          },
          &amp;#34;ruby&amp;#34;,
          &amp;#34;-I&amp;#34;, File.expand_path(&amp;#34;../..&amp;#34;, $LOADED_FEATURES.grep(/bundler\/setup\.rb$/).first),
          &amp;#34;-I&amp;#34;, File.expand_path(&amp;#34;../..&amp;#34;, __FILE__),
          &amp;#34;-e&amp;#34;, &amp;#34;require &amp;#39;spring/application/boot&amp;#39;&amp;#34;,
          3 =&amp;gt; child_socket,
          4 =&amp;gt; spring_env.log_file,
        )
      end

      start_wait_thread(pid, child) if child.gets
      child_socket.close
    end

    # ....

  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;这里Spring::ApplicationManager在start之后，会启动一个子进程，让子进程的文件描述符3指向自己建立的一对UNIXSocket的其中一端，并且之后在自己这个父进程中关闭该端，只保留从@child发信到子进程manager的功能&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;那么start_child又是从何调用的呢？&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;于是加入pp caller，再rails c。但无任何输出，考虑到这里这里代码所处的进程可能不是最终rails c所看到的进程，又或是其文件描述符被重定向过，只好将调用栈输出到文件&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# spring-2.0.2/lib/spring/application_manager.rb
def start_child(preload = false)
  File.open(&amp;#39;/tmp/spring_manager_start_child&amp;#39;, &amp;#39;w+&amp;#39;) do |f|
    f.puts caller
    f.puts &amp;#39;------------&amp;#39;
  end

  @child, child_socket = UNIXSocket.pair
  # ...
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;重新spring stop; rails c，在检查日志文件，可见调用栈如下：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;➜  ~ cat /tmp/spring_manager_start_child
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application_manager.rb:93:in `open&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application_manager.rb:93:in `start_child&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application_manager.rb:26:in `start&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application_manager.rb:52:in `block in with_child&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application_manager.rb:20:in `synchronize&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application_manager.rb:39:in `with_child&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/application_manager.rb:60:in `run&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/server.rb:65:in `serve&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/server.rb:49:in `block in start_server&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/server.rb:49:in `loop&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/server.rb:49:in `start_server&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/server.rb:43:in `boot&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/server.rb:14:in `boot&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client/server.rb:10:in `call&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client/command.rb:7:in `call&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client.rb:30:in `run&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/bin/spring:49:in `&lt;/code&gt;&lt;main&gt;&lt;code&gt;&amp;#39;&lt;/code&gt;&lt;/main&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;再看回执行rails c的步骤：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;因文件bin/rails被binstub过，所以会在执行rails命令前，先加载bin/spring&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env ruby
begin
  load File.expand_path(&amp;#39;../spring&amp;#39;, __FILE__)
rescue LoadError =&amp;gt; e
  raise unless e.message.include?(&amp;#39;spring&amp;#39;)
end
APP_PATH = File.expand_path(&amp;#39;../config/application&amp;#39;, __dir__)
require_relative &amp;#39;../config/boot&amp;#39;
require &amp;#39;rails/commands&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而bin/spring会运行spring这个gem的spring/binstub&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env ruby
unless defined?(Spring)
  require &amp;#39;rubygems&amp;#39;
  require &amp;#39;bundler&amp;#39;

  lockfile = Bundler::LockfileParser.new(Bundler.default_lockfile.read)
  spring = lockfile.specs.detect { |spec| spec.name == &amp;#34;spring&amp;#34; }
  if spring
    Gem.use_paths Gem.dir, Bundler.bundle_path.to_s, *Gem.path
    gem &amp;#39;spring&amp;#39;, spring.version
    require &amp;#39;spring/binstub&amp;#39;
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;来到spring/binstub，它会执行spring这个gem的bin/spring文件。而如果是rails命令，还会先将rails压到ARGV的前端&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# lib/spring/binstub.rb
command  = File.basename($0)
bin_path = File.expand_path(&amp;#34;../../../bin/spring&amp;#34;, __FILE__)

# ...

if command == &amp;#34;spring&amp;#34;
  load bin_path
else
  disable = ENV[&amp;#34;DISABLE_SPRING&amp;#34;]

  if Process.respond_to?(:fork) &amp;amp;&amp;amp; (disable.nil? || disable.empty? || disable == &amp;#34;0&amp;#34;)
    ARGV.unshift(command)
    load bin_path
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而bin/spring是这样的，将ARGV传给Spring::Client.run&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;lib = File.expand_path(&amp;#34;../../lib&amp;#34;, __FILE__)
$LOAD_PATH.unshift lib unless $LOAD_PATH.include?(lib) # enable local development
require &amp;#39;spring/client&amp;#39;
Spring::Client.run(ARGV)&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;于是便接上了上面ApplicationManager#run -&amp;gt; ApplicationManager#start_child的调用栈。调用栈中涉及的server代码如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# spring-2.0.2/lib/spring/server.rb
module Spring
  class Server
    def self.boot(options = {})
      new(options).boot
    end

    attr_reader :env

    def initialize(options = {})
      @foreground   = options.fetch(:foreground, false)
      @env          = options[:env] || default_env
      @applications = Hash.new { |h, k| h[k] = ApplicationManager.new(k, env) }
      @pidfile      = env.pidfile_path.open(&amp;#39;a&amp;#39;)
      @mutex        = Mutex.new
    end

    def boot
      Spring.verify_environment

      write_pidfile
      set_pgid unless foreground?
      ignore_signals unless foreground?
      set_exit_hook
      set_process_title
      start_server
    end

    def start_server
      server = UNIXServer.open(env.socket_name)
      log &amp;#34;started on #{env.socket_name}&amp;#34;
      loop { serve server.accept }
    rescue Interrupt
    end

    def serve(client)
      log &amp;#34;accepted client&amp;#34;
      client.puts env.version

      app_client = client.recv_io
      command    = JSON.load(client.read(client.gets.to_i))

      args, default_rails_env = command.values_at(&amp;#39;args&amp;#39;, &amp;#39;default_rails_env&amp;#39;)

      if Spring.command?(args.first)
        log &amp;#34;running command #{args.first}&amp;#34;
        client.puts
        client.puts @applications[rails_env_for(args, default_rails_env)].run(app_client)
      else
        log &amp;#34;command not found #{args.first}&amp;#34;
        client.close
      end
    rescue SocketError =&amp;gt; e
      raise e unless client.eof?
    ensure
      redirect_output
    end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;这里可以看到，server其实是UNIXServer.open(env.socket_name)，于是搜下socket_name，看还有哪里会用它来建立管道，得：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;module Spring
  module Client
    class Run &amp;lt; Command
      attr_reader :server

      def connect
        File.open(&amp;#39;/tmp/spring_client_run_connect&amp;#39;, &amp;#39;w+&amp;#39;) do |f|
          f.puts caller
          f.puts &amp;#39;-----------------&amp;#39;
        end
        @server = UNIXSocket.open(env.socket_name)
      end

      def call
        begin
          connect
        rescue Errno::ENOENT, Errno::ECONNRESET, Errno::ECONNREFUSED
          cold_run
        else
          warm_run
        end
      ensure
        server.close if server
      end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;在上面代码加入调用栈打印后，再运行spring stop;rails c，得：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;➜  ~ cat /tmp/spring_client_run_connect
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client/run.rb:26:in `open&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client/run.rb:26:in `connect&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client/run.rb:61:in `cold_run&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client/run.rb:37:in `rescue in call&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client/run.rb:34:in `call&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client/command.rb:7:in `call&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client/rails.rb:24:in `call&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client/command.rb:7:in `call&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/client.rb:30:in `run&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/bin/spring:49:in `&amp;lt;top (required)=&quot;&quot;&amp;gt;&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/binstub.rb:31:in `load&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/spring-2.0.2/lib/spring/binstub.rb:31:in `&amp;lt;top (required)=&quot;&quot;&amp;gt;&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/2.5.0/rubygems/core_ext/kernel_require.rb:70:in `require&amp;#39;
/home/z/.rbenv/versions/2.5.1/lib/ruby/2.5.0/rubygems/core_ext/kernel_require.rb:70:in `require&amp;#39;
/home/z/test_ruby/rays/bin/spring:15:in `&amp;lt;top (required)=&quot;&quot;&amp;gt;&amp;#39;
bin/rails:3:in `load&amp;#39;
bin/rails:3:in `&amp;lt;/top&amp;gt;&amp;lt;/top&amp;gt;&amp;lt;/top&amp;gt;&lt;/code&gt;&lt;main&gt;&lt;code&gt;&amp;#39;&lt;/code&gt;&lt;/main&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;但因为刚才有spring stop，所以这次进入了cold_run。那么它如何分辨cold_run还是warm_run呢？其实就是作为server的UNIXSocket.open(env.socket_name)文件并未建立。于是，如下面源码所述，它会进入boot_server方法，里面会另起一个进程，执行shell命令spring server（env.server_command）&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# spring-2.0.2/lib/spring/client/run.rb
def connect
  @server = UNIXSocket.open(env.socket_name)
end

def call
  begin
    connect
  rescue Errno::ENOENT, Errno::ECONNRESET, Errno::ECONNREFUSED
    cold_run
  else
    warm_run
  end
ensure
  server.close if server
end

def cold_run
  boot_server
  connect
  run
end

def boot_server
  env.socket_path.unlink if env.socket_path.exist?

  pid     = Process.spawn(gem_env, env.server_command, out: File::NULL)
  timeout = Time.now + BOOT_TIMEOUT

  @server_booted = true

  until env.socket_path.exist?
    _, status = Process.waitpid2(pid, Process::WNOHANG)

    if status
      exit status.exitstatus
    elsif Time.now &amp;gt; timeout
      $stderr.puts &amp;#34;Starting Spring server with `#{env.server_command}` &amp;#34; \
                   &amp;#34;timed out after #{BOOT_TIMEOUT} seconds&amp;#34;
      exit 1
    end

    sleep 0.1
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而根据lib/spring/client.rb里的命令匹配，&lt;span style=&quot;font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;&quot;&gt;shell命令spring server对应的就是Spring::&lt;/span&gt;Client::Server，其执行的就是Spring::Server.boot，于是这就又接回了上面ApplicationManager#run -&amp;gt; ApplicationManager#start_child的调用栈。&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;至此，所有进程间通讯都可串联起来了，图形如下：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/64ea7d8a2c7fc2cabdb0d69a990f8905/2a2d595e6ed9a0b24f027f2b63b134d6.gif&quot; type=&quot;image/gif&quot; data-filename=&quot;spring.gif&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;</content><author><name></name></author><category term="rails" /><category term="ruby" /><summary type="html">rails新建项目时，已经进行过binstub。这时输入rails c，即调用了spring，会打印出“Running via Spring preloader in process”的字样。可凭这些日志信息，到源码中查找它的调用过程。发现日志由以下方法输出，于是加入pp cal...</summary></entry><entry><title type="html">Resque::Mailer的运作</title><link href="/2019/06/20/d85bb470288b890c0425399f527d303a.html" rel="alternate" type="text/html" title="Resque::Mailer的运作" /><published>2019-06-20T00:00:00+00:00</published><updated>2019-06-20T00:00:00+00:00</updated><id>/2019/06/20/d85bb470288b890c0425399f527d303a</id><content type="html" xml:base="/2019/06/20/d85bb470288b890c0425399f527d303a.html">&lt;div&gt;跟踪一下include了Resque::Mailer的一个ActionMailer::Base子类Notifier的运作&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;[2] pry(main)&amp;gt; binding.trace_tree(htmp: &amp;#39;resque_mailer&amp;#39;){ Notifier.send_an_email(&amp;#39;a@b.com&amp;#39;, &amp;#39;subject&amp;#39;, &amp;#39;content&amp;#39;).deliver }
  Rendered notifier/send_an_email.html.erb within layouts/notifier (1.7ms)

Notifier#send_an_email: processed outbound mail in 70.8ms
=&amp;gt; true&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;得调用栈如下：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/d85bb470288b890c0425399f527d303a/966fd60eee1a84fc34340fc5ada1e04c.html&quot;&gt;&lt;img src=&quot;/assets/files/d85bb470288b890c0425399f527d303a/80575672010a217168e0d4d377d22173.png&quot; alt=&quot;20190620_111819_204_resque_mailer.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;基本流程如下：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/d85bb470288b890c0425399f527d303a/be53a0541a6d36f6ecb879fa2c584b08.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;ActionMailer::Base的子类只需定义实例方法，调用时按类方法来调，然后进入method_missing，如果方法action_methods计算出的controller实例方法包含该方法名，则将实际类名、方法名和参数包装成一个MessageDecoy&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;module Resque
  module Mailer
    class &amp;lt;&amp;lt; self
     def included(base)
       base.extend(ClassMethods)
     end
   end

   module ClassMethods
     def method_missing(method_name, *args)
       if action_methods.include?(method_name.to_s)
         MessageDecoy.new(self, method_name, *args)
       else
         super
       end
     end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;MessageDecoy的deliver就是通过Resque塞到redis里&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;def deliver
  return deliver! if environment_excluded?

  if @mailer_class.deliver?
    begin
      resque.enqueue(@mailer_class, @method_name, @serialized_args)
    rescue Errno::ECONNREFUSED, Redis::CannotConnectError
      logger.error &amp;#34;Unable to connect to Redis; falling back to synchronous mail delivery&amp;#34; if logger
      deliver!
    end
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;注意塞进resque的参数应是能准确序列化和反序列化的&lt;/div&gt;</content><author><name></name></author><category term="rails" /><category term="ruby" /><summary type="html">跟踪一下include了Resque::Mailer的一个ActionMailer::Base子类Notifier的运作...</summary></entry><entry><title type="html">bullet如何检测N+1问题</title><link href="/2019/06/11/be1f02950d4458260d73682ed6af2204.html" rel="alternate" type="text/html" title="bullet如何检测N+1问题" /><published>2019-06-11T00:00:00+00:00</published><updated>2019-06-11T00:00:00+00:00</updated><id>/2019/06/11/be1f02950d4458260d73682ed6af2204</id><content type="html" xml:base="/2019/06/11/be1f02950d4458260d73682ed6af2204.html">&lt;div&gt;先在controller里构造出一个N+1查询，然后根据rails log打印出的提示“Add to your finder…”，查找bullet代码，在其中加入打印caller语句，看是哪里开始调用的&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;module Bullet
  module Notification
    class NPlusOneQuery &amp;lt; Base

     def body
       pp &amp;#39;----------------------&amp;#39;
       pp caller
       &amp;#34;#{klazz_associations_str}\n  Add to your finder: #{associations_str}&amp;#34;
     end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;得调用栈如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;[&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet/notification/base.rb:41:in `body_with_caller&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet/notification/base.rb:61:in `notification_data&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet/notification/n_plus_one_query.rb:23:in `notification_data&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet/notification/base.rb:45:in `notify_inline&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet.rb:177:in `block in gather_inline_notifications&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet.rb:243:in `block (2 levels) in for_each_active_notifier_with_notification&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/2.3.0/set.rb:306:in `each_key&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/2.3.0/set.rb:306:in `each&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet.rb:241:in `block in for_each_active_notifier_with_notification&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet.rb:240:in `each&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet.rb:240:in `for_each_active_notifier_with_notification&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet.rb:176:in `gather_inline_notifications&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet/rack.rb:23:in `call&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/rack-1.5.5/lib/rack/etag.rb:23:in `call&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/rack-1.5.5/lib/rack/conditionalget.rb:25:in `call&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/rack-1.5.5/lib/rack/head.rb:11:in `call’&amp;#34;,
# …&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;可见其是通过增加一层rack来产生作用的，于是想将其call方法的调用栈打印出来，但鉴于里面@app.call(env)还调了下层rack，可能dump出来的东西太大，所以只关注下Bullet.perform_out_of_channel_notifications这段&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;module Bullet
  class Rack
    include Dependency

    def call(env)
       # …
        status, headers, response = @app.call(env)
        # ...
        binding.trace_tree(htmp: &amp;#39;bullet_perform&amp;#39;) do
          Bullet.perform_out_of_channel_notifications(env)
        end
      end
      [status, headers, response_body ? [response_body] : response]
    ensure
      Bullet.end_request
    end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;得调用栈如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/47e5d0b8062df7fd8626034f03144506.html&quot;&gt;&lt;img src=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/73722b3e42c3ae64a3e212b7e6940f69.png&quot; alt=&quot;20190611_171322_811_bullet_perform.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;但这其实看不出什么，只能看到发现它是将每种警告（notification）塞给警报器（notifier），然后调用notification.notify_out_of_channel来输出警告信息&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;def for_each_active_notifier_with_notification
  UniformNotifier.active_notifiers.each do |notifier|
    notification_collector.collection.each do |notification|
      notification.notifier = notifier
      yield notification
    end
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;于是，回到Bullet::Notification::NPlusOneQuery，看其是如何生成的&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;module Bullet
  module Notification
    class NPlusOneQuery &amp;lt; Base
      def initialize(callers, base_class, associations, path = nil)
        pp &amp;#39;--------------&amp;#39;
        pp caller
        super(base_class, associations, path)

        @callers = callers
      end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;打印出的调用栈很多，连query cache也会new NPlusOneQuery，摘取一条如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;  Load (1.9ms)  SELECT   FROM &amp;#34;stores&amp;#34;  WHERE &amp;#34;stores&amp;#34;.&amp;#34;id&amp;#34; = $1  ORDER BY &amp;#34;stores&amp;#34;.&amp;#34;created_at&amp;#34; ASC LIMIT 1  [[&amp;#34;id&amp;#34;, &amp;#34;......................&amp;#34;]]
&amp;#34;--------------&amp;#34;
[&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet/detector/n_plus_one_query.rb:91:in `new&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet/detector/n_plus_one_query.rb:91:in `create_notification&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet/detector/n_plus_one_query.rb:25:in `call_association&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/bullet-6.0.0/lib/bullet/active_record41.rb:164:in `reader&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/.rbenv/versions/2.3.8/lib/ruby/gems/2.3.0/gems/activerecord-4.1.16/lib/active_record/associations/builder/association.rb:110:in `store&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/Projects/rebasing/r................../app/models/...................rb:31:in `store_name&amp;#39;&amp;#34;,
&amp;#34;/Users/yuanzhipeng/Projects/rebasing/............../app/views/.................../index.html.erb:69:in `block (2 levels) in _app_views_………..._index_html_erb___202976205520604906_70249725434600’”,&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;可见各种Notification是通过重写ActiveRecord的方法，在其中进行拦截而产生的&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# bullet-6.0.0/lib/bullet/active_record41.rb
module Bullet
  module ActiveRecord
    def self.enable
      require &amp;#39;active_record&amp;#39;

      ::ActiveRecord::Associations::SingularAssociation.class_eval do
        # call has_one and belongs_to associations
        alias_method :origin_reader, :reader
        def reader(force_reload = false)
          result = origin_reader(force_reload)
          if Bullet.start?
            if @owner.class.name !~ /^HABTM_/ &amp;amp;&amp;amp; !@inversed
              Bullet::Detector::NPlusOneQuery.call_association(@owner, @reflection.name)
              Bullet::Detector::NPlusOneQuery.add_possible_objects(result)
            end
          end
          result
        end
      end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;call_association产生的Notification会塞入Thread.current[:bullet_notification_collector]，然后add_possible_objects会将对象的类和id记录到Thread.current[:bullet_possible_objects]中&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;但这还是没看出bullet_notification_collector和bullet_possible_objects怎样（甚至有没有）被用于统计N+1。观察rack的代码，感觉其实可以直接跟踪Bullet.start_request和Bullet.end_request包裹查询语句时的执行过程，这样dump出的调用栈会比rack中的少很多，分析起来也方便一些，于是：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;[3] pry(main)&amp;gt; binding.trace_tree(htmp: &amp;#39;bullet_not_in_rack&amp;#39;) do
[3] pry(main)*   begin
[3] pry(main)*     Bullet.start_request
[3] pry(main)*     PgOrder.limit(2).map(&amp;amp;:store)
[3] pry(main)*     Bullet.perform_out_of_channel_notifications
[3] pry(main)*   ensure
[3] pry(main)*     Bullet.end_request
[3] pry(main)*   end
[3] pry(main)* end
  PgOrder Load (36.6ms)  SELECT  &amp;#34;orders&amp;#34;.* FROM &amp;#34;orders&amp;#34;   ORDER BY orders.created_at DESC LIMIT 2
  Store Load (23.4ms)  SELECT  &amp;#34;stores&amp;#34;.* FROM &amp;#34;stores&amp;#34;  WHERE &amp;#34;stores&amp;#34;.&amp;#34;id&amp;#34; = $1  ORDER BY &amp;#34;stores&amp;#34;.&amp;#34;created_at&amp;#34; ASC LIMIT 1  [[&amp;#34;id&amp;#34;, “……………….&amp;#34;]]
  Store Load (37.8ms)  SELECT  &amp;#34;stores&amp;#34;.* FROM &amp;#34;stores&amp;#34;  WHERE &amp;#34;stores&amp;#34;.&amp;#34;id&amp;#34; = $1  ORDER BY &amp;#34;stores&amp;#34;.&amp;#34;created_at&amp;#34; ASC LIMIT 1  [[&amp;#34;id&amp;#34;, &amp;#34;……………….&amp;#34;]]
user: yuanzhipeng

USE eager loading detected
  PgOrder =&amp;gt; [:store]
  Add to your finder: :includes =&amp;gt; [:store]
Call stack
  /Users/yuanzhipeng/Projects/rebasing/………../bin/rails:8:in `&lt;/code&gt;&lt;main&gt;&lt;code&gt;&amp;#39;


=&amp;gt; [UniformNotifier::RailsLogger]
[4] pry(main)&amp;gt;&lt;/code&gt;&lt;/main&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;得调用栈如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/e559cdc539086df550aa99838f9001a9.html&quot;&gt;&lt;img src=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/fcd70b101af12b2a0dd0ab66c10a8ca6.png&quot; alt=&quot;20190613_112701_996_bullet_not_in_rack.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;再跟踪一下1+1（不是N+1）的情况，即limit(1).map，得调用栈&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/79c7193508eef8ed26e28d81f1ed90ad.html&quot;&gt;&lt;img src=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/3052ce7e5352f762dc1621010a9d0be7.png&quot; alt=&quot;20190613_115732_899_bullet_not_in_rack.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;一对比，可以发现1+1时Bullet.notification_collector.collection是空&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/be53a0541a6d36f6ecb879fa2c584b08.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;于是检查下call_association的执行路径上，是什么条件导致Bullet.notification_collector没有调用add&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;module Bullet
  module Detector
    class NPlusOneQuery &amp;lt; Association
      extend Dependency
      extend StackTraceFilter

      class &amp;lt;&amp;lt;self         #=&quot;&quot; executed=&quot;&quot; when=&quot;&quot; object.assocations=&quot;&quot; is=&quot;&quot; called.=&quot;&quot;         #=&quot;&quot; first,=&quot;&quot; it=&quot;&quot; keeps=&quot;&quot; this=&quot;&quot; method=&quot;&quot; call=&quot;&quot; for=&quot;&quot; object.association.=&quot;&quot;         #=&quot;&quot; then,=&quot;&quot; it=&quot;&quot; checks=&quot;&quot; if=&quot;&quot; this=&quot;&quot; associations=&quot;&quot; call=&quot;&quot; is=&quot;&quot; unpreload.=&quot;&quot;         #   if=&quot;&quot; it=&quot;&quot; is,=&quot;&quot; keeps=&quot;&quot; this=&quot;&quot; unpreload=&quot;&quot; associations=&quot;&quot; and=&quot;&quot; caller.=&quot;&quot;         def=&quot;&quot; call_association(object,=&quot;&quot; associations)=&quot;&quot;           return=&quot;&quot; unless=&quot;&quot; bullet.start?=&quot;&quot;           return=&quot;&quot; unless=&quot;&quot; bullet.n_plus_one_query_enable?=&quot;&quot;           return=&quot;&quot; unless=&quot;&quot; object.bullet_primary_key_value=&quot;&quot;           return=&quot;&quot; if=&quot;&quot; inversed_objects.include?(object.bullet_key,=&quot;&quot; associations)=&quot;&quot;           add_call_object_associations(object,=&quot;&quot; associations)=&quot;&quot;           bullet.debug('detector::nplusonequery#call_association',=&quot;&quot; &quot;object:=&quot;&quot; #{object.bullet_key},=&quot;&quot; associations:=&quot;&quot; #{associations}&quot;)=&quot;&quot;           if=&quot;&quot; !excluded_stacktrace_path?=&quot;&quot; &amp;amp;&amp;amp;=&quot;&quot; conditions_met?(object,=&quot;&quot; associations)=&quot;&quot;             bullet.debug('detect=&quot;&quot; n=&quot;&quot; +=&quot;&quot; 1=&quot;&quot; query',=&quot;&quot; &quot;object:=&quot;&quot; #{object.bullet_key},=&quot;&quot; associations:=&quot;&quot; #{associations}&quot;)=&quot;&quot;             create_notification=&quot;&quot; caller_in_project,=&quot;&quot; object.class.to_s,=&quot;&quot; associations=&quot;&quot;           end=&quot;&quot;         end=&quot;&quot;         private=&quot;&quot;         def=&quot;&quot; create_notification(callers,=&quot;&quot; klazz,=&quot;&quot; associations)=&quot;&quot;           notify_associations=&quot;Array(associations)&quot; -=&quot;&quot; bullet.get_whitelist_associations(:n_plus_one_query,=&quot;&quot; klazz)=&quot;&quot;           if=&quot;&quot; notify_associations.present?=&quot;&quot;             notice=&quot;Bullet::Notification::NPlusOneQuery.new(callers,&quot; klazz,=&quot;&quot; notify_associations)=&quot;&quot;             bullet.notification_collector.add(notice)=&quot;&quot;           end=&quot;&quot;         end&amp;lt;=&quot;&quot; code=&quot;&quot;&amp;gt;&amp;lt;/self&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;检查call_association中!excluded_stacktrace_path?和conditions_met?(object, associations)的返回值，发现1+1时conditions_met?为false，而N+1时，两次conditions_met?都为true，因此1+1不会有create_notification&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/91eee3f8d75dbb327ede474944726554.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/f7cb588f62bc16ba6c8ac0b4956bd711.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而conditions_met?是这样的：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;def conditions_met?(object, associations)
  possible?(object) &amp;amp;&amp;amp; !impossible?(object) &amp;amp;&amp;amp; !association?(object, associations)
end

def possible?(object)
  possible_objects.include? object.bullet_key
end

def impossible?(object)
  impossible_objects.include? object.bullet_key
end

# check if object =&amp;gt; associations already exists in object_associations.
def association?(object, associations)
  value = object_associations[object.bullet_key]
  value&amp;amp;.each do |v|
      # associations == v comparison order is important here because
      # v variable might be a squeel node where :== method is redefined,
      # so it does not compare values at all and return unexpected results
    result = v.is_a?(Hash) ? v.key?(associations) : associations == v
    return true if result
  end

  false
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;在调用栈上搜索possible_objects从何处填入，发现是被patch过的find_by_sql&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/caebd5802a502287b56167f6208b00f3.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;当某类的查询返回条数大于1时，就将其纳入“可能N+1”中&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;module Bullet
  module ActiveRecord
    def self.enable
      require &amp;#39;active_record&amp;#39;

      ::ActiveRecord::Base.class_eval do
        class &amp;lt;&amp;lt; self
          alias_method :origin_find_by_sql, :find_by_sql
          def find_by_sql(sql, binds = [])
            result = origin_find_by_sql(sql, binds)
            if Bullet.start?
              if result.is_a? Array
                if result.size &amp;gt; 1
                  Bullet::Detector::NPlusOneQuery.add_possible_objects(result)
                  Bullet::Detector::CounterCache.add_possible_objects(result)
                elsif result.size == 1
                  Bullet::Detector::NPlusOneQuery.add_impossible_object(result.first)
                  Bullet::Detector::CounterCache.add_impossible_object(result.first)
                end
              elsif result.is_a? ::ActiveRecord::Base
                Bullet::Detector::NPlusOneQuery.add_impossible_object(result)
                Bullet::Detector::CounterCache.add_impossible_object(result)
              end
            end
            result
          end
        end
      end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而impossible_objects，则在整个调用栈里都没找到add_impossible_object，应该就是因为走了result.size &amp;gt; 1的add_possible_objects而不走add_impossible_object。那为什么还需要possible?(object) &amp;amp;&amp;amp; !impossible?(object)呢？未明……&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;至于association?，其object_associations[object.bullet_key]所得的set是空的，所以没有each循环&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/7788f29195a2edf255b072ee25029997.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;搜索一下代码，见有add_object_associations及一些调用的地方，其中一个如下：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;::ActiveRecord::FinderMethods.class_eval do
  # add includes in scope
  alias_method :origin_find_with_associations, :find_with_associations
  def find_with_associations
    return origin_find_with_associations { |r| yield r } if block_given?

    records = origin_find_with_associations
    if Bullet.start?
      associations = (eager_load_values + includes_values).uniq
      records.each do |record|
        Bullet::Detector::Association.add_object_associations(record, associations)
      end
      Bullet::Detector::UnusedEagerLoading.add_eager_loadings(records, associations)
    end
    records
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;但add_object_associations在刚才的调用栈是没有找到的。根据注释，这应该是重写了includes的执行路径，在其中进行拦截。于是跟踪一下includes：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;[27] pry(main)&amp;gt; binding.trace_tree(htmp: &amp;#39;bullet_not_in_rack&amp;#39;) do
[27] pry(main)*   begin
[27] pry(main)*     Bullet.start_request
[27] pry(main)*     PgOrder.limit(2).includes(:store).map(&amp;amp;:store)
[27] pry(main)*     Bullet.perform_out_of_channel_notifications
[27] pry(main)*   ensure
[27] pry(main)*     Bullet.end_request
[27] pry(main)*   end
[27] pry(main)* end
  PgOrder Load (23.2ms)  SELECT  &amp;#34;orders&amp;#34;.* FROM &amp;#34;orders&amp;#34;   ORDER BY orders.created_at DESC LIMIT 2
  Store Load (30.7ms)  SELECT &amp;#34;stores&amp;#34;.* FROM &amp;#34;stores&amp;#34;  WHERE &amp;#34;stores&amp;#34;.&amp;#34;id&amp;#34; IN (&amp;#39;02573e9c-6bee-4771-a1e3-90cdc945d68b&amp;#39;)  ORDER BY &amp;#34;stores&amp;#34;.&amp;#34;created_at&amp;#34; ASC
=&amp;gt; [UniformNotifier::RailsLogger]
[28] pry(main)&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;得调用栈：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/3999f125c0d664ec61d5009b093f83e9.html&quot;&gt;&lt;img src=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/4fd9d3d9f4e08c885f77fbf3c14526aa.png&quot; alt=&quot;20190613_162136_422_bullet_not_in_rack.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;这includes对add_object_associations的调用是在重写的preloaders_on里的，那find_with_associations应该是其他情况了&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/905100afa8889d8584ad793d20552c6f.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;由于这次塞入了object_associations，所以possible?(object) &amp;amp;&amp;amp; !impossible?(object) &amp;amp;&amp;amp; !association?(object, associations)为false，便没有再create_notification了&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/be1f02950d4458260d73682ed6af2204/7be07b88dd0e09dacc662baaa2e84c35.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;那“多余preload的检测”是怎样执行的呢？猜测是因为没有了call_association的add_call_object_associations，所以应该能在Bullet.perform_out_of_channel_notifications时，筛选出有object_associations但无call_object_associations的associations，进而得出多余的preload&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;</content><author><name></name></author><category term="rails" /><category term="ruby" /><summary type="html">先在controller里构造出一个N+1查询，然后根据rails log打印出的提示“Add to your finder…”，查找bullet代码，在其中加入打印caller语句，看是哪里开始调用的...</summary></entry><entry><title type="html">rails的reload机制</title><link href="/2019/06/10/be99fb0e81d437717546e2c29fa28a3a.html" rel="alternate" type="text/html" title="rails的reload机制" /><published>2019-06-10T00:00:00+00:00</published><updated>2019-06-10T00:00:00+00:00</updated><id>/2019/06/10/be99fb0e81d437717546e2c29fa28a3a</id><content type="html" xml:base="/2019/06/10/be99fb0e81d437717546e2c29fa28a3a.html">&lt;div&gt;根据rails guide里constant reloading一节的描述，如果修改了某些代码，想在rails console里重新加载，可输入reload!&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;此命令其实是调用railties-5.2.1/lib/rails/console/app.rb中的Rails.application.reloader.reload!&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;于是跟踪一下：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;[3] pry(main)&amp;gt; binding.trace_tree(htmp: &amp;#39;rails_reload_bang&amp;#39;){ Rails.application.reloader.reload! }&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;得调用栈如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/be99fb0e81d437717546e2c29fa28a3a/ca9222caddf360ba50fdcfcc9c30b9ee.html&quot;&gt;&lt;img src=&quot;/assets/files/be99fb0e81d437717546e2c29fa28a3a/55c2180b5c8a5b9d7868b529be2848e7.png&quot; alt=&quot;20190610_141305_091_rails_reload_bang.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;从activesupport-5.2.1/lib/active_support/reloader.rb来看，这reloader的实现比较复杂，它在实际执行run!和complete!的前后，还要执行ExecutionWrapper的run!和complete!，而这些run!和complete!其实是callback……所以调用栈来回跳跃，还包含了一大堆callback机制的调用……&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# activesupport-5.2.1/lib/active_support/reloader.rb
module ActiveSupport
  class Reloader &amp;lt; ExecutionWrapper

    def self.reload!
      executor.wrap do
        new.tap do |instance|
          begin
            instance.run!
          ensure
            instance.complete!
          end
        end
      end
      prepare!
    end

# activesupport-5.2.1/lib/active_support/execution_wrapper.rb
module ActiveSupport
  class ExecutionWrapper
    include ActiveSupport::Callbacks

    def self.wrap
      return yield if active?
      instance = run!
      begin
        yield
      ensure
        instance.complete!
      end
    end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;甚至，reloader里根本没包含任何reload的逻辑，只能从该文件里的一些特别的字眼，如class_unload，去dump出的调用栈里搜索，结果还是发现一些蛛丝马迹：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/be99fb0e81d437717546e2c29fa28a3a/be53a0541a6d36f6ecb879fa2c584b08.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;如上，Rails.application.reloader.reload!是会调用class_unload!的，而这个方法会转而调用railties-5.2.1/lib/rails/application/finisher.rb里定义的回调，该回调执行的就是ActiveSupport::DescendantsTracker.clear和ActiveSupport::Dependencies.clear&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# railties-5.2.1/lib/rails/application/finisher.rb
module Rails
  class Application
    module Finisher
      include Initializable

      initializer :set_clear_dependencies_hook, group: :all do |app|
        callback = lambda do
          ActiveSupport::DescendantsTracker.clear
          ActiveSupport::Dependencies.clear
        end

        if config.cache_classes
          app.reloader.check = lambda { false }
        elsif config.reload_classes_only_on_change
          app.reloader.check = lambda do
            app.reloaders.map(&amp;amp;:updated?).any?
          end
        else
          app.reloader.check = lambda { true }
        end

        if config.reload_classes_only_on_change
          reloader = config.file_watcher.new(*watchable_args, &amp;amp;callback)
          reloaders &amp;lt;&amp;lt; reloader

          # Prepend this callback to have autoloaded constants cleared before
          # any other possible reloading, in case they need to autoload fresh
          # constants.
          app.reloader.to_run(prepend: true) do
            # In addition to changes detected by the file watcher, if routes
            # or i18n have been updated we also need to clear constants,
            # that&amp;#39;s why we run #execute rather than #execute_if_updated, this
            # callback has to clear autoloaded constants after any update.
            class_unload! do
              reloader.execute
            end
          end
        else
          app.reloader.to_complete do
            class_unload!(&amp;amp;callback)
          end
        end
      end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;其中ActiveSupport::DescendantsTracker.clear用于对include了ActiveSupport::DescendantsTracker的类清理其对子类的跟踪信息&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;而ActiveSupport::Dependencies.clear代码量就有点大了，于是另外再跟踪一次：&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;[7] pry(main)&amp;gt; binding.trace_tree(htmp: &amp;#39;dep_clear&amp;#39;){ ActiveSupport::Dependencies.clear }&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;得调用栈如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;/assets/files/be99fb0e81d437717546e2c29fa28a3a/2dc56d6f071dc1313836133a643d0419.html&quot;&gt;&lt;img src=&quot;/assets/files/be99fb0e81d437717546e2c29fa28a3a/2040a73431ba7b40ab17df0cde82d794.png&quot; alt=&quot;20190611_145854_583_dep_clear.html&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;其实基本骨架还是比较清晰的&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;def clear
  Dependencies.unload_interlock do
    loaded.clear
    loading.clear
    remove_unloadable_constants!
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;运行起来就是这样&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;/assets/files/be99fb0e81d437717546e2c29fa28a3a/91eee3f8d75dbb327ede474944726554.png&quot; type=&quot;image/png&quot; data-filename=&quot;Image.png&quot; /&gt;&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;这里面loaded和loading保存的都是文件路径，用于记录哪些代码文件已经加载过，而remove_unloadable_constants!则是调用remove_constant清除常量，其实现如下&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;def remove_constant(const) #:nodoc:
  # Normalize ::Foo, ::Object::Foo, Object::Foo, Object::Object::Foo, etc. as Foo.
  normalized = const.to_s.sub(/\A::/, &amp;#34;&amp;#34;)
  normalized.sub!(/\A(Object::)+/, &amp;#34;&amp;#34;)

  constants = normalized.split(&amp;#34;::&amp;#34;)
  to_remove = constants.pop

  # Remove the file path from the loaded list.
  file_path = search_for_file(const.underscore)
  if file_path
    expanded = File.expand_path(file_path)
    expanded.sub!(/\.rb\z/, &amp;#34;&amp;#34;)
    loaded.delete(expanded)
  end

  if constants.empty?
    parent = Object
  else
    # This method is robust to non-reachable constants.
    #
    # Non-reachable constants may be passed if some of the parents were
    # autoloaded and already removed. It is easier to do a sanity check
    # here than require the caller to be clever. We check the parent
    # rather than the very const argument because we do not want to
    # trigger Kernel#autoloads, see the comment below.
    parent_name = constants.join(&amp;#34;::&amp;#34;)
    return unless qualified_const_defined?(parent_name)
    parent = constantize(parent_name)
  end

  # In an autoloaded user.rb like this
  #
  #   autoload :Foo, &amp;#39;foo&amp;#39;
  #
  #   class User &amp;lt; ActiveRecord::Base
  #   end
  #
  # we correctly register &amp;#34;Foo&amp;#34; as being autoloaded. But if the app does
  # not use the &amp;#34;Foo&amp;#34; constant we need to be careful not to trigger
  # loading &amp;#34;foo.rb&amp;#34; ourselves. While #const_defined? and #const_get? do
  # require the file, #autoload? and #remove_const don&amp;#39;t.
  #
  # We are going to remove the constant nonetheless ---which exists as
  # far as Ruby is concerned--- because if the user removes the macro
  # call from a class or module that were not autoloaded, as in the
  # example above with Object, accessing to that constant must err.
  unless parent.autoload?(to_remove)
    begin
      constantized = parent.const_get(to_remove, false)
    rescue NameError
      # The constant is no longer reachable, just skip it.
      return
    else
      constantized.before_remove_const if constantized.respond_to?(:before_remove_const)
    end
  end

  begin
    parent.instance_eval { remove_const to_remove }
  rescue NameError
    # The constant is no longer reachable, just skip it.
  end
end&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;实际上它就是找出一个常量的父级命名空间，然后在其中调用remove_const，并顺便调用before_remove_const（如果有定义的话）&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;至此，class和module什么的应该都被清掉了，当再次读到常量名字时，就又会走Dependencies里定义的const_missing回调去加载代码，实现reload&lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;/div&gt;</content><author><name></name></author><category term="rails" /><category term="ruby" /><summary type="html">根据rails guide里constant reloading一节的描述，如果修改了某些代码，想在rails console里重新加载，可输入reload!...</summary></entry></feed>